#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
增强版Web应用示例
================

这个脚本演示了带有完整错误处理和日志记录功能的Flask REST API。
"""

from flask import Flask, request, jsonify
import sqlite3
import logging
import os

app = Flask(__name__)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# 数据库配置
DB_PATH = 'contacts.db'

# 数据库连接
def get_db():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

# 初始化数据库
def init_db():
    logger.info("初始化数据库")
    if not os.path.exists(DB_PATH):
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS contacts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT NOT NULL,
            phone TEXT
        )
        ''')
        conn.commit()
        conn.close()
        logger.info("数据库初始化完成")
    else:
        logger.info("数据库已存在")

# 初始化数据库
init_db()

# 错误处理装饰器
def handle_exceptions(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except sqlite3.Error as e:
            logger.error(f"数据库错误: {str(e)}")
            return jsonify({"error": f"数据库错误: {str(e)}"}), 500
        except Exception as e:
            logger.error(f"服务器错误: {str(e)}")
            return jsonify({"error": f"服务器错误: {str(e)}"}), 500
    wrapper.__name__ = func.__name__
    return wrapper

@app.route('/contacts', methods=['GET'])
@handle_exceptions
def get_contacts():
    logger.info("获取所有联系人")
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM contacts')
    contacts = [dict(row) for row in cursor.fetchall()]
    conn.close()
    logger.info(f"返回 {len(contacts)} 个联系人")
    return jsonify(contacts)

@app.route('/contacts', methods=['POST'])
@handle_exceptions
def add_contact():
    logger.info("添加新联系人")
    data = request.json
    
    # 验证输入
    if not data or 'name' not in data or 'email' not in data:
        logger.warning("无效的请求数据")
        return jsonify({"error": "缺少必要字段 (name, email)"}), 400
    
    name = data['name']
    email = data['email']
    phone = data.get('phone', '')
    
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute(
        'INSERT INTO contacts (name, email, phone) VALUES (?, ?, ?)',
        (name, email, phone)
    )
    conn.commit()
    new_id = cursor.lastrowid
    conn.close()
    
    logger.info(f"联系人已添加，ID: {new_id}")
    return jsonify({'message': '联系人已添加', 'id': new_id}), 201

@app.route('/contacts/<int:contact_id>', methods=['GET'])
@handle_exceptions
def get_contact(contact_id):
    logger.info(f"获取联系人 ID: {contact_id}")
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM contacts WHERE id = ?', (contact_id,))
    contact = cursor.fetchone()
    conn.close()
    
    if contact is None:
        logger.warning(f"联系人 ID {contact_id} 不存在")
        return jsonify({"error": "联系人不存在"}), 404
    
    logger.info(f"返回联系人 ID: {contact_id}")
    return jsonify(dict(contact))

@app.route('/contacts/<int:contact_id>', methods=['PUT'])
@handle_exceptions
def update_contact(contact_id):
    logger.info(f"更新联系人 ID: {contact_id}")
    
    # 检查联系人是否存在
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM contacts WHERE id = ?', (contact_id,))
    contact = cursor.fetchone()
    
    if contact is None:
        conn.close()
        logger.warning(f"联系人 ID {contact_id} 不存在")
        return jsonify({"error": "联系人不存在"}), 404
    
    # 更新联系人
    data = request.json
    if not data:
        conn.close()
        logger.warning("无效的请求数据")
        return jsonify({"error": "无效的请求数据"}), 400
    
    name = data.get('name')
    email = data.get('email')
    phone = data.get('phone')
    
    if name is None and email is None and phone is None:
        conn.close()
        logger.warning("没有提供要更新的字段")
        return jsonify({"error": "没有提供要更新的字段"}), 400
    
    # 获取当前值作为默认值
    current = dict(contact)
    name = name if name is not None else current['name']
    email = email if email is not None else current['email']
    phone = phone if phone is not None else current['phone']
    
    cursor.execute(
        'UPDATE contacts SET name = ?, email = ?, phone = ? WHERE id = ?',
        (name, email, phone, contact_id)
    )
    conn.commit()
    conn.close()
    
    logger.info(f"联系人 ID {contact_id} 已更新")
    return jsonify({'message': '联系人已更新'})

@app.route('/contacts/<int:contact_id>', methods=['DELETE'])
@handle_exceptions
def delete_contact(contact_id):
    logger.info(f"删除联系人 ID: {contact_id}")
    
    # 检查联系人是否存在
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM contacts WHERE id = ?', (contact_id,))
    contact = cursor.fetchone()
    
    if contact is None:
        conn.close()
        logger.warning(f"联系人 ID {contact_id} 不存在")
        return jsonify({"error": "联系人不存在"}), 404
    
    cursor.execute('DELETE FROM contacts WHERE id = ?', (contact_id,))
    conn.commit()
    conn.close()
    
    logger.info(f"联系人 ID {contact_id} 已删除")
    return jsonify({'message': '联系人已删除'})

# 错误处理器
@app.errorhandler(404)
def not_found(error):
    logger.warning(f"404 错误: {request.path}")
    return jsonify({'error': '资源不存在'}), 404

@app.errorhandler(500)
def server_error(error):
    logger.error(f"500 错误: {str(error)}")
    return jsonify({'error': '服务器内部错误'}), 500

@app.errorhandler(405)
def method_not_allowed(error):
    logger.warning(f"405 错误: {request.method} {request.path}")
    return jsonify({'error': '方法不允许'}), 405

@app.errorhandler(400)
def bad_request(error):
    logger.warning(f"400 错误: {request.path}")
    return jsonify({'error': '无效请求'}), 400

# 路由未找到时的处理
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def catch_all(path):
    logger.warning(f"尝试访问未定义的路由: {path}")
    return jsonify({'error': '路由未找到'}), 404

if __name__ == '__main__':
    logger.info("应用启动")
    app.run(debug=True)
    logger.info("应用关闭")
